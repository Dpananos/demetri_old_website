{
  "hash": "af2942ecd9ef2873a5004e24cd6927ed",
  "result": {
    "markdown": "---\ntitle: \"Neat Litle Combinatorics Problem\"\nauthor: \"Demetri Pananos\"\ndate: \"2018-08-31\"\ncategories: [Python, Probability]\n---\n\nI'll cut right to it.  Consider the set $S = (49, 8, 48, 15, 47, 4, 16, 23, 43, 44, 42, 45, 46 )$.  What is the expected value for the minimum of 6 samples from this set?\n\nWe could always just sample form the set to estimate the expected value.  Here is a python script to do just that.\n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\nimport numpy as np\nx = np.array([49, 8, 48, 15, 47, 4, 16, 23, 43, 44, 42, 45, 46])\n\nmins = []\nfor _ in range(1000):\n    mins.append(np.random.choice(x,size = 6, replace = False).min())\n\nprint(np.mean(mins))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n9.098\n```\n:::\n:::\n\n\nBut that is estimating the mean.  We can do better and directly compute it.  Here is some python code to create all subsets from $S$ of size 6.  Then, we simply take out the minimum from each subset and compute the mean.\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\nimport numpy as np\nfrom itertools import combinations, groupby\n\nx = np.array([49, 8, 48, 15, 47, 4, 16, 23, 43, 44, 42, 45, 46])\nx = np.sort(x)\n\nc = list(combinations(x,6))\n\nmins = list(map(lambda x: x[0], c))\n\ns = 0\nfor k, g in groupby(sorted(mins)):\n    s+=k*(len(list(g))/len(mins))\n\nprint( s )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n8.818181818181818\n```\n:::\n:::\n\n\nThe script returns 8.18 repeating.  Great, but we can do even better!  If we can compute the probability density function, we can compute the mean analytically.  Let's consider a smaller problem to outline the solution.\n\nLet our set in question be $(1,2,3,4,5)$.  Let the minimum of a sample of 3 numbers from this set be the random variable $z$.  Now, note there are $\\binom{5}{3} = 10$ ways to choose 3 elements from a set of 5.\n\nHow many subsets exist where the minimum is 1?  Well, if I sampled 1, then I would still have to pick 2 numbers from a possible 4 numbers larger than 1.  There are $\\binom{4}{2}$ ways to do this. So $p(z=1) = \\binom{4}{2} / \\binom{5}{3}$.\n\nIn a similar fashion, there are $\\binom{3}{2}$ subsets where 2 is the minimum, and $\\binom{2}{2}$ subsets where 3 is the minimum.  There are no subsets where 4 or 5 are the minimum (why?).  So that means the expected minimum value for this set would be\n\n\n$$\\operatorname{E}(z) = \\dfrac{ \\sum_{k = 1}^{3} k\\binom{5-k}{2} }{\\binom{5}{3}}  $$\n\n\nWhatever that sum happens to be. Here is how you could code up the analytic solution to our problem.\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\nimport numpy as np\nfrom scipy.special import binom\n\nx = np.array([ 4, 8, 15, 16, 23, 42, 43, 44, 45, 46, 47, 48, 49])\nx = np.sort(x)\n\nsample_size =6\nsample_space = x[:-(sample_size-1)]\nE = 0\nfor i,s in enumerate(sample_space,start = 1):\n\n    E+= s*binom(x.size-i,sample_size-1)\n\nprint(E/binom(x.size, sample_size))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n8.818181818181818\n```\n:::\n:::\n\n\nFull disclosure, this was on a job application (literally, on the job application), so sorry KiK for putting the answer out there, but the question was too fun not to write up!\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}